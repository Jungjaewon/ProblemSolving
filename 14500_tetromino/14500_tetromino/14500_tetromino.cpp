#define _CRT_SECURE_NO_WARNINGS
#include <iostream>


/*
한시간 조금 넘게 걸렸다.

도형의 한점을 기준을 00으로 잡고 모든 파생도형의 좌표를 만들고 범위 안이면 더하고 아니면 브레이크 종료를 하면서 검사를 했다.
첫번째 예제 문제의 답이 19인데 왜 19인지 찾으면서 시간을 날렸다..?? 코딩이랑은 상관없는 부분


이전에 푼 문제인거 같은데 정확하게 기억은 나지 않는다.
3차원 배열로 해서 활용을 했다. 그래서 코드가 더 간결해졌다.
다음에도 활용하면 좋을거 같다.
*/
int N, M;

int arr[501][501];
int ans = -10e9;

int a1[][2] = { {0,0}, {0,1}, {0,2}, {0,3} };
int a2[][2] = {{0,0}, {0,-1}, {0,-2}, {0,-3}};
int a3[][2] = { {0,0}, {1,0}, {2,0}, {3,0} };
int a4[][2] = { {0,0}, {-1,0}, {-2,0}, {-3,0} };

int type1[][4][2] = {{{0,0}, {0,1}, {0,2}, {0,3}},{{0,0}, {0,-1}, {0,-2}, {0,-3}},{ {0,0}, {1,0}, {2,0}, {3,0} },{ {0,0}, {-1,0}, {-2,0}, {-3,0} }};

int type2[][2] = { {0,0}, {0,1}, {1,0}, {1,1} };

int c1[][2] = { {0,0}, {1,0}, {2,0}, {2,1} };
int c2[][2] = { {0,0}, {0,1}, {0,2}, {-1,2} };
int c3[][2] = { {0,0}, {-1,0}, {-2,0}, {-2,-1} };
int c4[][2] = { {0,0}, {0,-1}, {0,-2}, {1,-2} };

int c5[][2] = { {0,0}, {1,0}, {2,0}, {2,-1} };
int c6[][2] = { {0,0}, {0,-1}, {0,-2}, {-1,-2} };
int c7[][2] = { {0,0}, {-1,0}, {-2,0}, {-2,1} };
int c8[][2] = { {0,0}, {0,1}, {0,2}, {1,2} };

int type3[][4][2] = { { {0,0}, {1,0}, {2,0}, {2,1} },{ {0,0}, {0,1}, {0,2}, {-1,2} },{ {0,0}, {-1,0}, {-2,0}, {-2,-1} },{ {0,0}, {0,-1}, {0,-2}, {1,-2} },
{ {0,0}, {1,0}, {2,0}, {2,-1} }, { {0,0}, {-1,0}, {-2,0}, {-2,1} }, { {0,0}, {-1,0}, {-2,0}, {-2,1} }, {{0,0}, {0,1}, {0,2}, {1,2}} };

int d1[][2] = { {0,0}, {1,0}, {1,1}, {1,2} };
int d2[][2] = { {0,0}, {0,1}, {-1,1}, {-1,2} };
int d3[][2] = { {0,0}, {-1,0}, {-1,-1}, {-2,-1} };
int d4[][2] = { {0,0}, {0,-1}, {1,-1}, {1,-2} };

int d5[][2] = { {0,0}, {1,0}, {1,-1}, {1,-2} };
int d6[][2] = { {0,0}, {0,1}, {1,1}, {1,2} };
int d7[][2] = { {0,0}, {-1,0}, {-1,1}, {-2,1} };
int d8[][2] = { {0,0}, {0,-1}, {-1,-1}, {-1,-2} };

int type4[][4][2] = { {{0,0}, {1,0}, {1,1}, {1,2}} ,{{0,0}, {0,1}, {-1,1}, {-1,2}}, {{0,0}, {-1,0}, {-1,-1}, {-2,-1}},{{0,0}, {0,-1}, {1,-1}, {1,-2}}
,{{0,0}, {1,0}, {1,-1}, {1,-2}}, {{0,0}, {0,1}, {1,1}, {1,2}}, {{0,0}, {-1,0}, {-1,1}, {-2,1}}, {{0,0}, {0,-1}, {-1,-1}, {-1,-2}} };

int e1[][2] = {{0,0}, {0,-1}, {0,1}, {1,0}};
int e2[][2] = {{0,0}, {-1,0}, {1,0}, {0,-1}};
int e3[][2] = {{0,0}, {0,-1}, {0,1}, {-1,0}};
int e4[][2] = {{0,0}, {-1,0}, {1,0}, {0,1}};

int type5[][4][2] = { {{0,0}, {0,-1}, {0,1}, {1,0}}, {{0,0}, {-1,0}, {1,0}, {0,-1}}, {{0,0}, {0,-1}, {0,1}, {-1,0}}, {{0,0}, {-1,0}, {1,0}, {0,1}} };


int max_value(int a, int b) {
	if (a > b)
		return a;
	else
		return b;
}

void processing(int mode, int x, int y) {

	int result = 0;
	if (mode==1) {
		for (int i = 0; i < 4; ++i) {
			for (int j = 0; j < 4; ++j) {
				if (1 <= x + type1[i][j][0] && x + type1[i][j][0] <= N && 1 <= y + type1[i][j][1] && y + type1[i][j][1] <= M) {
					result += arr[x + type1[i][j][0]][y + type1[i][j][1]];
				}
				else {
					result = 0;
					break;
				}
			}
			ans = max_value(ans, result);
			result = 0;
		}
	}
	else if (mode==2) {
		for (int j = 0; j < 4; ++j) {
			if (1 <= x + type2[j][0] && x + type2[j][0] <= N && 1 <= y + type2[j][1] && y + type2[j][1] <= M) {
				result += arr[x + type2[j][0]][y + type2[j][1]];
			}
			else 
				return;
		}
		ans = max_value(ans, result);
	}
	else if (mode == 3) {
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 4; ++j) {
				if (1 <= x + type3[i][j][0] && x + type3[i][j][0] <= N && 1 <= y + type3[i][j][1] && y + type3[i][j][1] <= M) {
					result += arr[x + type3[i][j][0]][y + type3[i][j][1]];
				}
				else {
					result = 0;
					break;
				}
			}
			ans = max_value(ans, result);
			result = 0;
		}
	}
	else if (mode == 4) {
		for (int i = 0; i < 8; ++i) {
			for (int j = 0; j < 4; ++j) {
				if (1 <= x + type4[i][j][0] && x + type4[i][j][0] <= N && 1 <= y + type4[i][j][1] && y + type4[i][j][1] <= M) {
					result += arr[x + type4[i][j][0]][y + type4[i][j][1]];
				}
				else {
					result = 0;
					break;
				}
			}
			ans = max_value(ans, result);
			result = 0;
		}
	}
	else if (mode == 5) {
		for (int i = 0; i < 4; ++i) {
			for (int j = 0; j < 4; ++j) {
				if (1 <= x + type5[i][j][0] && x + type5[i][j][0] <= N && 1 <= y + type5[i][j][1] && y + type5[i][j][1] <= M) {
					result += arr[x + type5[i][j][0]][y + type5[i][j][1]];
				}
				else {
					result = 0;
					break;
				}
			}
			ans = max_value(ans, result);
			result = 0;
		}
	}
}
int main()
{
	freopen("input.txt","r",stdin);
	scanf("%d %d",&N,&M);

	for (int i = 1; i <= N; ++i) {
		for (int j = 1; j <= M; ++j) {
			scanf("%d",&arr[i][j]);
		}
	}

	for (int mode = 1; mode <= 5; ++mode) {
		for (int x = 1; x <= N; ++x) {
			for (int y = 1; y <= M; ++y) {
				processing(mode, x, y);
			}
		}
	}

	printf("%d",ans);
	return 0;
}

